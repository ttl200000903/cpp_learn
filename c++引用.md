# 引用  

## 引用只是指针的一种语法糖，没有事是引用能做但指针不能做的

**在具体应用方面会不同**  
引用是为了增加代码易读性  
引用指对现有变量引用的一种方式  
和指针不同，指针中沿线创建一个指针变量，然后给指针赋值  
引用不行  
引用必须停用一个已存在的变量，引用本身并不是一个新的变量  
***
接下来是例子
***

```c++
int main(){
    int a=5;
    int& ref=a;
 std::cin.get();
}
```

并不是有&就一定是取地址或引用，具体情况看上下文  
在这里他挨着变量类型，所以是引用  
此段代码创建了一个别名  
ref不是变量是引用，此时编译程序不会生成a，ref两个变量只有a  

```c++
int a=5;
int& ref=a;
ref=2;
Log(a);
std::cin.get();
```

输出a的值为2  
ref就是a，给a创建了一个别名  
**以上案列引用之不是指针，编译器没有必要创建新变量**，
但a输出的值为2，如果给某个变量一个别名，引用能让代码更好写  
***

* 复杂点的例子

***
假设要创建一个函数，使得输入的整数递增

```c++
void Increment(int value){
    value++;
}
```

此时创建变量a，然后调用这个函数，并将a作为参数  

```c++
int a=5;
Increment(a);
Log(a);
```

由于是传值调用，这里不是指针或引用，所以调用过程中程序将会拷贝参数值5进入函数，**此时输出值是5**  
>a没有增加，只是value增加了

此时需要**引用传递**这个变量让他递增，因为a变量没有被影响  
可以不传递5这个值进函数，**直接传递a变量的地址**

```cpp
void Increment(int* value)
{
 (*value)++;//要用逆向引用，不然递增的是内存地址
}
```

此时输出值为6  
**将代码改为引用**  

```cpp
void Increment(int& value)//将指针形参改成引用形式
{
 value++;
}
int main()
{
 int a = 5;
 Increment(a);
 Log(a);
 std::cin.get();
}
```

此时输出结果和之前一致<mark>a为6</mark>  

引用只是指针的一种语法糖，没有事是引用能做但指针不能做的
==

***
一旦声明了一个引用，就不能改变它所引用的对象  
一个简单的例子
***

```cpp
int a=5;
int b=8;

int& ref=a;
ref=b;
```

**不能这么写**
这里新建了一个对a的引用ref，然后设置ref=b；  
声明一个引用时，必须将一个实际的变量赋值给它  
不能只声明不赋值  
将代码改为

```c++
int a=5;
int b=8;

int* ref=&a;
*ref=2;
ref=&b;
*ref=1;
```

先创建一些变量使它先指向a，然后再让他指向b  
此时a=2,b=1  
